TernarySplitter  in 747ms
return (mismatchA == null) && (mismatchB == null)
return (mismatchA == null) && (mismatchB == null)
return (key != null) && (key.length() > 0)
Preconditions.checkState(references != null)
Preconditions.checkState(key != null)
Preconditions.checkState(id != null)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return JsMessage.Hash.hash64(value, 0, value == null ? 0 : value.length, seed)
Preconditions.checkState(var != null, "Type tightener could not find variable with name %s", lhs.getString())
return ((parent != null) && parent.isAssign()) && (parent.getFirstChild() != n)
Preconditions.checkArgument((node == null) || node.isExprResult())
Preconditions.checkState(explicitNode == null)
return explicitNode != null
return ((value != null) && value.isObjectLit()) && (!value.hasChildren())
boolean singleGlobalParentDecl = ((owner != null) && (owner.getDeclaration() != null)) && (owner.localSets == 0)
boolean singleGlobalParentDecl = ((owner != null) && (owner.getDeclaration() != null)) && (owner.localSets == 0)
boolean isKnownAlias = aliaser.isCall() && ((convention.getClassesDefinedByCall(aliaser) != null) || (convention.getSingletonGetterClassName(aliaser) != null))
boolean isKnownAlias = aliaser.isCall() && ((convention.getClassesDefinedByCall(aliaser) != null) || (convention.getSingletonGetterClassName(aliaser) != null))
return n.getFirstChild() != null
return (reservedKeywords != null) && reservedKeywords.contains(identifier)
return (grandchild != null) && grandchild.isFunction()
return !((functionName == null) || (!ExportTestFunctions.TEST_FUNCTIONS_NAME_PATTERN.matcher(functionName).matches()))
boolean isTopFunction = thatIsVarArgs && (((thatParamType == null) || thatParamType.isUnknownType()) || thatParamType.isNoType())
return (returnType == null) || returnType.isUnknownType()
return ((((((objType == null) || invalidatingTypes.contains(objType)) || (!objType.hasReferenceName())) || objType.isUnknownType()) || objType.isEmptyType()) || objType.isEnumType()) || (objType.autoboxesTo() != null)
return ((((((objType == null) || invalidatingTypes.contains(objType)) || (!objType.hasReferenceName())) || objType.isUnknownType()) || objType.isEmptyType()) || objType.isEnumType()) || (objType.autoboxesTo() != null)
return (info != null) && info.isConstructor()
Preconditions.checkArgument(stringValue != null)
Node marker = IR.string(interfaceType == null ? "instance_of__" + className : "implements__" + interfaceType.getReferenceName())
return NodeUtil.isExprCall(next) && (compiler.getCodingConvention().getClassesDefinedByCall(next.getFirstChild()) != null)
Preconditions.checkArgument(paths != null)
Preconditions.checkArgument(showType != null)
handleUnresolvedType(t, (value == null) || value.isUnknownType())
Preconditions.checkState(aliasedFunctions == null)
Preconditions.checkState(((assign != null) && NodeUtil.isAssignmentOp(assign)) && (assign.getFirstChild() == n))
return code != null
boolean isNewStyleMessage = (msgNode != null) && msgNode.isCall()
Preconditions.checkState(jsRoot == null)
Preconditions.checkState(jsRoot == null)
final boolean dumpTraceReport = (options != null) && options.tracer.isOn()
Preconditions.checkState((compilerThread == null) || (compilerThread == Thread.currentThread()), "Please do not share the Compiler across threads")
Preconditions.checkState(currentTracer == null)
Preconditions.checkState(currentTracer != null, "Tracer should not be null at the end of a pass.")
Preconditions.checkState(getInput(id) == null, "Duplicate input %s", id.getIdName())
inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.dependencyOptions, inputs)
Preconditions.checkState(sourceName != null)
return (lastChild != null) && (lastChild.isOptionalArg() || lastChild.isVarArgs())
return (lastChild != null) && lastChild.isVarArgs()
boolean isOverride = ((parent.getJSDocInfo() != null) && parent.isAssign()) && (parent.getFirstChild() == getprop)
boolean sameInput = (referenceSource != null) && referenceSource.equals(definingSource)
return ((deprecatedDepth > 0) || (CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null)) || (((scopeRootParent != null) && scopeRootParent.isAssign()) && (CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent)) != null))
return ((deprecatedDepth > 0) || (CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null)) || (((scopeRootParent != null) && scopeRootParent.isAssign()) && (CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent)) != null))
return ((deprecatedDepth > 0) || (CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null)) || (((scopeRootParent != null) && scopeRootParent.isAssign()) && (CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent)) != null))
return CheckAccessControls.getTypeDeprecationInfo(type) != null
Assert.assertTrue((("Both types must be null, or both must be non-null " + a) + ",") + b, (a == null) == (b == null))
Assert.assertTrue((("Both types must be null, or both must be non-null " + a) + ",") + b, (a == null) == (b == null))
Preconditions.checkState(externsAndJs != null)
Preconditions.checkState((externsRoot == null) || externsAndJs.hasChild(externsRoot))
Preconditions.checkState(scopeCreator == null)
Preconditions.checkState(topScope == null)
Preconditions.checkState(jsRoot.getParent() != null)
boolean superClassHasProperty = (superClass != null) && superClass.getInstanceType().hasProperty(propertyName)
boolean superClassHasDeclaredProperty = (superClass != null) && superClass.getInstanceType().isPropertyTypeDeclared(propertyName)
boolean declaredOverride = (info != null) && info.isOverride()
return (((name != null) && (name.length() > 1)) && Character.isUpperCase(name.charAt(0))) && (!name.equals(name.toUpperCase()))
return ((parent == null) || (!parent.isScript())) || (!t.getInput().isExtern())
Preconditions.checkState((gramps != null) && gramps.isVar())
boolean notProvidedByConstructors = (constructors == null) || (!constructors.contains(className))
boolean notProvidedByRequires = (requires == null) || ((!requires.contains(className)) && (!requires.contains(outermostClassName)))
return externsRoot != null
return (v != null) && (!v.isLocal())
return s.getParent() == null
return ((info != null) && (valueNode != null)) && (((info.isConstructor() && valueNode.isFunction()) || (info.isInterface() && valueNode.isFunction())) || (info.hasEnumParameterType() && valueNode.isObjectLit()))
return ((info != null) && (valueNode != null)) && (((info.isConstructor() && valueNode.isFunction()) || (info.isInterface() && valueNode.isFunction())) || (info.hasEnumParameterType() && valueNode.isObjectLit()))
return ((!inExterns) && (!isGetOrSetDefinition())) && (declaredType || ((((parent == null) || parent.canCollapseUnannotatedChildNames()) && ((globalSets > 0) || (localSets > 0))) && (deleteProps == 0)))
return (parent == null) || parent.canCollapseUnannotatedChildNames()
return parent == null
Preconditions.checkState((body.getNext() == null) && body.isBlock())
assignedToUnknownValue = (value != null) && (!NodeUtil.isLiteralValue(value, true))
return getNode(n) != null
return (((n != null) && (n.isCall() || n.isNew())) && n.hasChildren()) && (qualifiedNameBeginsWithStripType(n.getFirstChild()) || nameEndsWithFieldNameToStrip(n.getFirstChild()))
return ((propNode != null) && propNode.isString()) && isStripName(propNode.getString())
return (((name != null) && name.isName()) && var.getName().equals(name.getString())) && NodeUtil.isAssignmentOp(n)
return (((name != null) && name.isName()) && var.getName().equals(name.getString())) && (!NodeUtil.isVarOrSimpleAssignLhs(name, name.getParent()))
Preconditions.checkState(compiler != null)
return currentInfo.getDescription() != null
return (((((((currentInfo.isConstructor() || currentInfo.isInterface()) || (currentInfo.getParameterCount() > 0)) || currentInfo.hasReturnType()) || currentInfo.hasBaseType()) || (currentInfo.getExtendedInterfacesCount() > 0)) || (currentInfo.getLendsName() != null)) || currentInfo.hasThisType()) || hasAnySingletonTypeTags()
Preconditions.checkState(externsAndJs != null)
Preconditions.checkState((externsRoot == null) || externsAndJs.hasChild(externsRoot))
return (info != null) && info.containsDeclaration()
allowDupe = (info != null) && info.getSuppressions().contains("duplicate")
return (isEmptyType() || isUnknownType()) || (getSlot(propertyName) != null)
return getOwnSlot(propertyName) != null
return getOwnerFunction() != null
return (input != null) && input.isReturn()
return !((ancestors.size() == 1) && (ancestors.peek().getNext() == null))
this.valueHasSideEffects = (valueNode != null) && NodeUtil.mayHaveSideEffects(valueNode)
return lookAhead != null
Preconditions.checkState(jsonml != null)
return input.getSourceFileName() != null
return getParameterType(parameter) != null
return thisType != null
return getBaseType() != null
return (info != null) && (info.modifies != null)
return (info != null) && (info.modifies != null)
return String.format("%s at %s line %s %s", description, Strings.isNullOrEmpty(sourceName) ? "(unknown source)" : sourceName, lineNumber < 0 ? String.valueOf(lineNumber) : "(unknown line)", lineSource != null ? ":\n\n" + lineSource : ".")
Preconditions.checkState(parent != null, "Cannot find continue target.")
return ControlFlowAnalysis.isBreakStructure(target, label != null) && ControlFlowAnalysis.matchLabel(target.getParent(), label)
return (variableParent != null) && variableParent.isParamList()
assert sourceFile != null
Preconditions.checkArgument(child.parent == null, "new child has existing parent")
Preconditions.checkArgument(child.next == null, "new child has existing sibling")
Preconditions.checkArgument(left.parent == null, "first new child has existing parent")
Preconditions.checkArgument(left.next == null, "first new child has existing sibling")
Preconditions.checkArgument(right.parent == null, "second new child has existing parent")
Preconditions.checkArgument(right.next == null, "second new child has existing sibling")
Preconditions.checkArgument(left.parent == null)
Preconditions.checkArgument(left.next == null)
Preconditions.checkArgument(mid.parent == null)
Preconditions.checkArgument(mid.next == null)
Preconditions.checkArgument(right.parent == null)
Preconditions.checkArgument(right.next == null)
Preconditions.checkArgument(left.parent == null)
Preconditions.checkArgument(left.next == null)
Preconditions.checkArgument(mid.parent == null)
Preconditions.checkArgument(mid.next == null)
Preconditions.checkArgument(mid2.parent == null)
Preconditions.checkArgument(mid2.next == null)
Preconditions.checkArgument(right.parent == null)
Preconditions.checkArgument(right.next == null)
Preconditions.checkArgument(children[i - 1].parent == null)
Preconditions.checkArgument(children[children.length - 1].parent == null)
return first != null
Preconditions.checkArgument(child.parent == null)
Preconditions.checkArgument(child.next == null)
Preconditions.checkArgument(child.parent == null)
Preconditions.checkArgument(child.next == null)
Preconditions.checkArgument(child.parent == null)
Preconditions.checkArgument((node != null) && (node.parent == this), "The existing child node of the parent should not be null.")
Preconditions.checkArgument(newChild.next == null, "The new child node has siblings.")
Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent.")
Preconditions.checkArgument(newChild.next == null, "The new child node has siblings.")
Preconditions.checkArgument((node == null) || (node.parent == this))
Preconditions.checkArgument(child.parent == null)
Preconditions.checkArgument(newChild.next == null, "The new child node has siblings.")
Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent.")
Preconditions.checkArgument(newChild.next == null, "The new child node has siblings.")
Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent.")
Preconditions.checkState(this.propListHead == null, "Node has existing properties.")
return current != null
return cur != null
return (first != null) && (first == last)
return (first != null) && (first != last)
Preconditions.checkState(parent != null)
Preconditions.checkArgument(prev.next != null, "no next sibling.")
boolean initialized = name.getDeclaration() != null
Preconditions.checkState(lang == null)
Preconditions.checkState((lang != null) && (!lang.isEmpty()))
Preconditions.checkState(msgBuilder == null)
Preconditions.checkState((id != null) && (!id.isEmpty()))
Preconditions.checkState(msgBuilder != null)
Preconditions.checkState(msgBuilder != null)
return new PassConfig.State(cssNames == null ? null : Maps.newHashMap(cssNames), exportedNames == null ? null : Collections.unmodifiableSet(exportedNames), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
return new PassConfig.State(cssNames == null ? null : Maps.newHashMap(cssNames), exportedNames == null ? null : Collections.unmodifiableSet(exportedNames), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
Preconditions.checkState((blacklist != null) && (!blacklist.isEmpty()), "Not checking use of goog.getCssName because of empty blacklist.")
return ObjectType.cast(type == null ? null : type.dereference())
boolean hasLendsName = (n.getJSDocInfo() != null) && (n.getJSDocInfo().getLendsName() != null)
boolean hasLendsName = (n.getJSDocInfo() != null) && (n.getJSDocInfo().getLendsName() != null)
return (((v != null) && v.isLocal()) && v.isMarkedEscaped()) && (v.getScope() == syntacticScope)
boolean descend = (((parent == null) || (!parent.isFunction())) || (n == parent.getFirstChild())) || (parent == scope.getRootNode())
boolean inferred = keyType == null
Preconditions.checkState(sourceName != null)
boolean isFnLiteral = (rValue != null) && rValue.isFunction()
defineSlot(name, parent, type, type == null)
Preconditions.checkArgument(inferred || (type != null))
boolean isValidValue = (initialValue != null) && (initialValue.isObjectLit() || initialValue.isQualifiedName())
scopeToDeclareIn.declare(prototypeName, n, prototypeSlot.getType(), input, (superClassCtor == null) || superClassCtor.getInstanceType().isEquivalentTo(getNativeType(JSTypeNative.OBJECT_TYPE)))
return (scope != null) && scope.isGlobal()
Preconditions.checkArgument((qName != null) && (ownerName != null))
Preconditions.checkArgument((qName != null) && (ownerName != null))
stubDeclarations.add(new TypedScopeCreator.StubDeclaration(n, (t.getInput() != null) && t.getInput().isExtern(), ownerName))
boolean isExtern = (t.getInput() != null) && t.getInput().isExtern()
inferred = !(((info.hasType() || info.hasEnumParameterType()) || ((info.isConstant() && (valueType != null)) && (!valueType.isUnknownType()))) || FunctionTypeBuilder.isFunctionTypeDeclaration(info))
return ObjectType.cast(ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined())
boolean inferred = (paramType == null) || (paramType == unknownType)
Preconditions.checkArgument(((module == null) || (this.module == null)) || (this.module == module))
Preconditions.checkArgument(((module == null) || (this.module == null)) || (this.module == module))
Preconditions.checkState(fnRecursionName != null)
Preconditions.checkState(parent.getFirstChild() == null)
boolean checkModules = isRemovable && (fnModule != null)
Preconditions.checkState(scope.getParent() == null)
compiler.report(JSError.make(NodeUtil.getSourceName(n), n, SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR, name, origVar.input != null ? origVar.input.getName() : "??"))
return (info != null) && info.getSuppressions().contains("duplicate")
return waiting == null
return (isDeclaration() && (!getParent().isVar())) || (nameNode.getFirstChild() != null)
return (((((parentType == Token.VAR) && (nameNode.getFirstChild() != null)) || (parentType == Token.INC)) || (parentType == Token.DEC)) || (NodeUtil.isAssignmentOp(parent) && (parent.getFirstChild() == nameNode))) || ReferenceCollectingCallback.Reference.isLhsOfForInExpression(nameNode)
return getParent() == null
return (gramps == null) || (!gramps.isScript())
Preconditions.checkArgument((source == null) || (Token.FUNCTION == source.getType()))
Preconditions.checkArgument((source == null) || (Token.FUNCTION == source.getType()))
Preconditions.checkArgument(name != null)
boolean replacedPrototype = oldPrototype != null
this.prototypeSlot = new Property("prototype", prototype, true, propertyNode == null ? source : propertyNode)
boolean treatThisTypesAsCovariant = ((((other.typeOfThis.toObjectType() != null) && (other.typeOfThis.toObjectType().getConstructor() != null)) && other.typeOfThis.toObjectType().getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis)) || this.typeOfThis.isSubtype(other.typeOfThis)
boolean treatThisTypesAsCovariant = ((((other.typeOfThis.toObjectType() != null) && (other.typeOfThis.toObjectType().getConstructor() != null)) && other.typeOfThis.toObjectType().getConstructor().isInterface()) || other.typeOfThis.isSubtype(this.typeOfThis)) || this.typeOfThis.isSubtype(other.typeOfThis)
return (prototypeSlot != null) || super.hasCachedValues()
boolean preferLineBreaks = (type == Token.SCRIPT) || ((((type == Token.BLOCK) && (!preserveBlock)) && (n.getParent() != null)) && n.getParent().isScript())
return (n == null) || ((!NodeUtil.canBeSideEffected(n)) && (!mayHaveSideEffects(n)))
boolean constructorHasArgs = constructorNameNode.getNext() != null
Preconditions.checkState(value.getParent() == null)
this(sourceName, node, node != null ? node.getLineno() : -1, node != null ? node.getCharno() : -1, type, null, arguments)
this(sourceName, node, node != null ? node.getLineno() : -1, node != null ? node.getCharno() : -1, type, null, arguments)
return (((((((type.key + ". ") + description) + " at ") + ((sourceName != null) && (sourceName.length() > 0) ? sourceName : "(unknown source)")) + " line ") + (lineNumber != (-1) ? String.valueOf(lineNumber) : "(unknown line)")) + " : ") + (charno != (-1) ? String.valueOf(charno) : "(unknown column)")
return classes != null
return (constructor != null) && constructor.isInterface()
boolean aliasable = (!unaliasableGlobals.contains(dest.getString())) && ((docInfo == null) || (!docInfo.isNoAlias()))
Preconditions.checkState(this.newName == null)
boolean local = ((var != null) && var.isLocal()) && ((!var.scope.getParent().isGlobal()) || (!var.isBleedingFunction()))
boolean isBleedingIntoScope = (s.getParent() != null) && localBleedingFunctions.contains(v)
return (name != null) && name.endsWith(CheckMissingGetCssName.GET_UNIQUE_ID_FUNCTION)
return (qname != null) && isIdName(qname)
return ((((((objType == null) || invalidatingTypes.contains(objType)) || (!objType.hasReferenceName())) || objType.isUnknownType()) || objType.isEmptyType()) || objType.isEnumType()) || (objType.autoboxesTo() != null)
return ((((((objType == null) || invalidatingTypes.contains(objType)) || (!objType.hasReferenceName())) || objType.isUnknownType()) || objType.isEmptyType()) || objType.isEnumType()) || (objType.autoboxesTo() != null)
Preconditions.checkState(meaning != null)
String projectScopedMeaning = (projectId != null ? projectId + ": " : "") + meaning
Preconditions.checkArgument(compiler != null)
Preconditions.checkArgument(safeNameIdSupplier != null)
Preconditions.checkArgument(changed != null)
Preconditions.checkState(fn != null)
return fn != null
Preconditions.checkState(this.fn == null)
return (references != null) && (!references.isEmpty())
return containingFunction(node) == null
Preconditions.checkArgument(typeofNode.getFirstChild() != null)
return (parent != null) && NodeUtil.isGet(parent)
Preconditions.checkArgument((inputsSupplier == null) ^ (modulesSupplier == null))
Preconditions.checkArgument((inputsSupplier == null) ^ (modulesSupplier == null))
Preconditions.checkState(specs != null)
Preconditions.checkState(jsFiles != null)
Preconditions.checkState(specs != null)
return (options.sourceMapOutputPath != null) && options.sourceMapOutputPath.contains("%outname%")
return ((!config.module.isEmpty()) && (output != null)) && output.contains("%outname%")
Preconditions.checkArgument(declaration.getJSType() != null)
return (((var.getParentNode() != null) && (var.getType() == null)) && var.getParentNode().isVar()) && (!var.isExtern())
return (((var.getParentNode() != null) && (var.getType() == null)) && var.getParentNode().isVar()) && (!var.isExtern())
return (input == null) || input.isExtern()
return (nameNode != null) && NodeUtil.isConstantName(nameNode)
return (info != null) && info.isDefine()
return (info != null) && info.isNoShadow()
Preconditions.checkState((name != null) && (name.length() > 0))
Preconditions.checkState(vars.get(name) == null)
return parent == null
Preconditions.checkState(expressionRoot != null)
boolean allowWith = (info != null) && info.getSuppressions().contains("with")
Preconditions.checkArgument(lastLink.nextLink == null)
Preconditions.checkArgument(unsafe != null)
return ((!skipRenaming) && (types != null)) && (types.allEquivalenceClasses().size() > 1)
compiler.report(JSError.make(t.getSourceName(), n, propertiesToErrorFor.get(name), DisambiguateProperties.Warnings.INVALIDATION, name, type == null ? "null" : type.toString(), n.toString(), suggestion))
compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name), DisambiguateProperties.Warnings.INVALIDATION, name, type == null ? "null" : type.toString(), n.toString(), ""))
return (objType != null) && (!objType.hasReferenceName())
return type.isEnumType() || (type.autoboxesTo() != null)
return (((type == null) || type.isAll()) || type.isFunction()) || (type.isInstance() && invalidatingTypes.contains(type.toInstance().instanceType))
return (((var != null) && (var.getScope() == s)) && (!isNamedParameter(var))) && (!blacklistedVars.contains(var))
return (displayName != null) && (!displayName.isEmpty())
return toMaybeUnionType() != null
return (info != null) && info.makesStructs()
return (info != null) && info.makesDicts()
return toMaybeFunctionType() != null
return toMaybeEnumElementType() != null
return toMaybeEnumType() != null
return toMaybeRecordType() != null
return toMaybeParameterizedType() != null
return toMaybeTemplateType() != null
assert record != null
return ((info != null) && info.hasParameterType(paramName)) && info.getParameterType(paramName).isOptionalArg()
return ((info != null) && info.hasParameterType(paramName)) && info.getParameterType(paramName).isVarArgs()
return (className != null) || (ownerFunction != null)
return (className != null) || (ownerFunction != null)
return (thatObj != null) && isImplicitPrototype(thatObj)
Preconditions.checkState((ownerFunction == null) || (type == null))
Preconditions.checkState((ownerFunction == null) || (type == null))
boolean aIsNull = (slotA == null) || (slotA.getType() == null)
boolean aIsNull = (slotA == null) || (slotA.getType() == null)
boolean bIsNull = (slotB == null) || (slotB.getType() == null)
boolean bIsNull = (slotB == null) || (slotB.getType() == null)
return (info != null) && info.isExpose()
boolean shouldBeConstant = ((info != null) && info.isConstant()) || NodeUtil.isConstantByConvention(compiler.getCodingConvention(), n, parent)
Preconditions.checkState(externsAndJs != null)
return (var != null) && var.isConst()
boolean isFirstMessageTranslated = bundle.getMessage(message1.getId()) != null
boolean isSecondMessageTranslated = bundle.getMessage(message2.getId()) != null
Preconditions.checkState(result != null)
return registerFunction != null
return registerCall != null
Preconditions.checkState(nameNode != null)
Preconditions.checkState(value != null)
Preconditions.checkState(value != null)
Preconditions.checkArgument(paths != null)
return properties.get(propertyName) != null
return getSlot(propertyName) != null
return properties.remove(name) != null
CheckNotNull  in 9298ms
