TernarySplitter  in 308ms
assert sourceFile != null
Preconditions.checkArgument(child.parent == null, "new child has existing parent")
Preconditions.checkArgument(child.next == null, "new child has existing sibling")
Preconditions.checkArgument(left.parent == null, "first new child has existing parent")
Preconditions.checkArgument(left.next == null, "first new child has existing sibling")
Preconditions.checkArgument(right.parent == null, "second new child has existing parent")
Preconditions.checkArgument(right.next == null, "second new child has existing sibling")
Preconditions.checkArgument(left.parent == null)
Preconditions.checkArgument(left.next == null)
Preconditions.checkArgument(mid.parent == null)
Preconditions.checkArgument(mid.next == null)
Preconditions.checkArgument(right.parent == null)
Preconditions.checkArgument(right.next == null)
Preconditions.checkArgument(left.parent == null)
Preconditions.checkArgument(left.next == null)
Preconditions.checkArgument(mid.parent == null)
Preconditions.checkArgument(mid.next == null)
Preconditions.checkArgument(mid2.parent == null)
Preconditions.checkArgument(mid2.next == null)
Preconditions.checkArgument(right.parent == null)
Preconditions.checkArgument(right.next == null)
Preconditions.checkArgument(children[i - 1].parent == null)
Preconditions.checkArgument(children[children.length - 1].parent == null)
return first != null
Preconditions.checkArgument(child.parent == null)
Preconditions.checkArgument(child.next == null)
Preconditions.checkArgument(child.parent == null)
Preconditions.checkArgument(child.next == null)
Preconditions.checkArgument(child.parent == null)
Preconditions.checkArgument(child.parent == null)
Preconditions.checkArgument(node != null, "The existing child node of the parent should not be null.")
Preconditions.checkArgument(newChild.next == null, "The new child node has siblings.")
Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent.")
Preconditions.checkArgument(newChild.next == null, "The new child node has siblings.")
Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent.")
Preconditions.checkArgument(newChild.next == null, "The new child node has siblings.")
Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent.")
Preconditions.checkArgument(newChild.next == null, "The new child node has siblings.")
Preconditions.checkArgument(newChild.parent == null, "The new child node already has a parent.")
Preconditions.checkState(this.propListHead == null, "Node has existing properties.")
return current != null
return cur != null
return (first != null) && (first == last)
return (first != null) && (first != last)
return checkTreeEqualsImpl(node2) == null
return checkTreeTypeAwareEqualsImpl(node2) == null
Preconditions.checkState(parent != null)
Preconditions.checkArgument(prev.next != null, "no next sibling.")
return (mismatchA == null) && (mismatchB == null)
return (mismatchA == null) && (mismatchB == null)
boolean initialized = name.declaration != null
return new PassConfig.State(cssNames == null ? null : Maps.newHashMap(cssNames), exportedNames == null ? null : Collections.unmodifiableSet(exportedNames), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
return new PassConfig.State(cssNames == null ? null : Maps.newHashMap(cssNames), exportedNames == null ? null : Collections.unmodifiableSet(exportedNames), crossModuleIdGenerator, variableMap, propertyMap, anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap)
Preconditions.checkState((blacklist != null) && (!blacklist.isEmpty()), "Not checking use of goog.getCssName because of empty blacklist.")
return ObjectType.cast(type == null ? null : type.dereference())
Preconditions.checkState(references != null)
boolean nonLocalInferredSlot = (isInferred && (syntacticScope.getParent() != null)) && (var == syntacticScope.getParent().getSlot(varName))
boolean hasLendsName = (n.getJSDocInfo() != null) && (n.getJSDocInfo().getLendsName() != null)
boolean hasLendsName = (n.getJSDocInfo() != null) && (n.getJSDocInfo().getLendsName() != null)
return (((parent == null) || (parent.getType() != Token.FUNCTION)) || (n == parent.getFirstChild())) || (parent == scope.getRootNode())
Preconditions.checkState(sourceName != null)
boolean isFnLiteral = (rValue != null) && (rValue.getType() == Token.FUNCTION)
defineSlot(name, parent, type, type == null)
Preconditions.checkArgument(inferred || (type != null))
scopeToDeclareIn.declare(variableName + ".prototype", n, fnType.getPrototype(), input, (superClassCtor == null) || superClassCtor.getInstanceType().equals(getNativeType(JSTypeNative.OBJECT_TYPE)))
Preconditions.checkArgument((qName != null) && (ownerName != null))
Preconditions.checkArgument((qName != null) && (ownerName != null))
stubDeclarations.add(new TypedScopeCreator.StubDeclaration(n, (t.getInput() != null) && t.getInput().isExtern(), ownerName))
inferred = !(((rhsValue != null) && (rhsValue.getType() == Token.FUNCTION)) && (!scope.isDeclared(qName, false)))
boolean isExtern = (t.getInput() != null) && t.getInput().isExtern()
return ObjectType.cast(ownerVarType == null ? null : ownerVarType.restrictByNotNullOrUndefined())
Preconditions.checkArgument(((module == null) || (this.module == null)) || (this.module == module))
Preconditions.checkArgument(((module == null) || (this.module == null)) || (this.module == module))
Preconditions.checkState(parent.getFirstChild() == null)
boolean checkModules = isRemovable && (fnModule != null)
Preconditions.checkState(key != null)
Preconditions.checkState(id != null)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return (((((((id.equals(m.id) && key.equals(m.key)) && (isAnonymous == m.isAnonymous)) && parts.equals(m.parts)) && (meaning == null ? m.meaning == null : meaning.equals(m.meaning))) && placeholders.equals(m.placeholders)) && (desc == null ? m.desc == null : desc.equals(m.desc))) && (sourceName == null ? m.sourceName == null : sourceName.equals(m.sourceName))) && (hidden == m.hidden)
return JsMessage.Hash.hash64(value, 0, value == null ? 0 : value.length, seed)
Preconditions.checkState(var != null, "Type tightener could not find variable with name %s", lhs.getString())
Preconditions.checkState(scope.getParent() == null)
allowDupe = (info != null) && info.getSuppressions().contains("duplicate")
compiler.report(JSError.make(sourceName, n, SyntacticScopeCreator.VAR_MULTIPLY_DECLARED_ERROR, name, origVar.input != null ? origVar.input.getName() : "??"))
Preconditions.checkArgument((node == null) || NodeUtil.isExpressionNode(node))
Preconditions.checkState(explicitNode == null)
return explicitNode != null
return ((value != null) && (value.getType() == Token.OBJECTLIT)) && (!value.hasChildren())
return ((name.parent != null) && (name.parent.aliasingGets == 0)) && (name.parent.type == GlobalNamespace.Name.Type.OBJECTLIT)
return waiting == null
return isDeclaration() && ((parent.getType() != Token.VAR) || (nameNode.getFirstChild() != null))
return (((((parentType == Token.VAR) && (nameNode.getFirstChild() != null)) || (parentType == Token.INC)) || (parentType == Token.DEC)) || (NodeUtil.isAssignmentOp(parent) && (parent.getFirstChild() == nameNode))) || ReferenceCollectingCallback.Reference.isLhsOfForInExpression(nameNode)
boolean hasObjectValues = values != null
return n.getFirstChild() != null
return (gramps == null) || (gramps.getType() != Token.SCRIPT)
Preconditions.checkArgument((source == null) || (Token.FUNCTION == source.getType()))
Preconditions.checkArgument((source == null) || (Token.FUNCTION == source.getType()))
Preconditions.checkArgument(name != null)
boolean replacedPrototype = prototype != null
boolean treatThisTypesAsCovariant = (((this.isConstructor() || other.isConstructor()) || ((other.typeOfThis.getConstructor() != null) && other.typeOfThis.getConstructor().isInterface())) || other.typeOfThis.isSubtype(this.typeOfThis)) || this.typeOfThis.isSubtype(other.typeOfThis)
return (prototype != null) || super.hasCachedValues()
Preconditions.checkState(childCount == ((n.getParent() != null) && (n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0))
boolean preferLineBreaks = (type == Token.SCRIPT) || ((((type == Token.BLOCK) && (!preserveBlock)) && (n.getParent() != null)) && (n.getParent().getType() == Token.SCRIPT))
return (n == null) || ((!NodeUtil.canBeSideEffected(n)) && (!NodeUtil.mayHaveSideEffects(n)))
boolean constructorHasArgs = constructorNameNode.getNext() != null
this(sourceName, node, node != null ? node.getLineno() : -1, node != null ? node.getCharno() : -1, type, null, arguments)
this(sourceName, node, node != null ? node.getLineno() : -1, node != null ? node.getCharno() : -1, type, null, arguments)
return (((((((type.key + ". ") + description) + " at ") + ((sourceName != null) && (sourceName.length() > 0) ? sourceName : "(unknown source)")) + " line ") + (lineNumber != (-1) ? String.valueOf(lineNumber) : "(unknown line)")) + " : ") + (charno != (-1) ? String.valueOf(charno) : "(unknown column)")
return classes != null
return (activationNames != null) && activationNames.containsKey(name)
boolean aliasable = (!unaliasableGlobals.contains(dest.getString())) && ((docInfo == null) || (!docInfo.isNoAlias()))
return (grandchild != null) && (grandchild.getType() == Token.FUNCTION)
return !((functionName == null) || (!ExportTestFunctions.TEST_FUNCTIONS_NAME_PATTERN.matcher(functionName).matches()))
return (returnType == null) || returnType.isUnknownType()
Preconditions.checkState(this.newName == null)
boolean local = (var != null) && var.isLocal()
return (name != null) && name.endsWith(CheckMissingGetCssName.GET_UNIQUE_ID_FUNCTION)
return (qname != null) && isIdName(qname)
return (((((objType == null) || invalidatingTypes.contains(objType)) || (!objType.hasReferenceName())) || objType.isUnknownType()) || objType.isEnumType()) || (objType.autoboxesTo() != null)
return (((((objType == null) || invalidatingTypes.contains(objType)) || (!objType.hasReferenceName())) || objType.isUnknownType()) || objType.isEnumType()) || (objType.autoboxesTo() != null)
Node marker = Node.newString(interfaceType == null ? "instance_of__" + className : "implements__" + interfaceType.getReferenceName())
return NodeUtil.isExprCall(next) && (compiler.getCodingConvention().getClassesDefinedByCall(next.getFirstChild()) != null)
boilerplateCode = boilerplateCode.replace("%%LOG%%", logFunction == null ? "function(warning, expr) {}" : logFunction)
Preconditions.checkArgument(compiler != null)
Preconditions.checkArgument(safeNameIdSupplier != null)
Preconditions.checkArgument(changed != null)
Preconditions.checkState(fn != null)
return fn != null
Preconditions.checkState(this.fn == null)
return (references != null) && (!references.isEmpty())
Preconditions.checkArgument(paths != null)
Preconditions.checkArgument(showType != null)
return containingFunction(node) == null
Preconditions.checkArgument(typeofNode.getFirstChild() != null)
handleUnresolvedType(t, (value == null) || value.isUnknownType())
Preconditions.checkState(aliasedFunctions == null)
return (parent != null) && NodeUtil.isGet(parent)
return code != null
boolean isNewStyleMessage = (msgNode != null) && (msgNode.getType() == Token.CALL)
Preconditions.checkState(jsRoot == null)
Preconditions.checkState(jsRoot == null)
Preconditions.checkState(currentTracer == null)
Preconditions.checkState(currentTracer != null, "Tracer should not be null at the end of a pass.")
Preconditions.checkState(getInput(sourceName) == null, "Duplicate input of name " + sourceName)
inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph).manageDependencies(options.manageClosureDependenciesEntryPoints, inputs)
Preconditions.checkState(sourceName != null)
Preconditions.checkArgument((inputsSupplier == null) ^ (modulesSupplier == null))
Preconditions.checkArgument((inputsSupplier == null) ^ (modulesSupplier == null))
Preconditions.checkState(specs != null)
Preconditions.checkState(jsFiles != null)
Preconditions.checkState(specs != null)
return (options.sourceMapOutputPath != null) && options.sourceMapOutputPath.contains("%outname%")
return ((!config.module.isEmpty()) && (config.outputManifest != null)) && config.outputManifest.contains("%outname%")
return (lastChild != null) && (lastChild.isOptionalArg() || lastChild.isVarArgs())
return (lastChild != null) && lastChild.isVarArgs()
return ((deprecatedDepth > 0) || (CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null)) || (((scopeRootParent != null) && (scopeRootParent.getType() == Token.ASSIGN)) && (CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent)) != null))
return ((deprecatedDepth > 0) || (CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null)) || (((scopeRootParent != null) && (scopeRootParent.getType() == Token.ASSIGN)) && (CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent)) != null))
return ((deprecatedDepth > 0) || (CheckAccessControls.getTypeDeprecationInfo(t.getScope().getTypeOfThis()) != null)) || (((scopeRootParent != null) && (scopeRootParent.getType() == Token.ASSIGN)) && (CheckAccessControls.getTypeDeprecationInfo(getClassOfMethod(scopeRoot, scopeRootParent)) != null))
return CheckAccessControls.getTypeDeprecationInfo(type) != null
Preconditions.checkArgument(declaration.getJSType() != null)
return (input == null) || input.isExtern()
Preconditions.checkState((name != null) && (name.length() > 0))
Preconditions.checkState(vars.get(name) == null)
var.isDefine = (info != null) && info.isDefine()
return parent == null
Preconditions.checkState(expressionRoot != null)
Preconditions.checkArgument(lastLink.nextLink == null)
boolean allowWith = (info != null) && info.getSuppressions().contains("with")
return (warningsGuard != null) && warningsGuard.enables(type)
return (warningsGuard != null) && warningsGuard.disables(type)
Preconditions.checkArgument(unsafe != null)
return ((!skipRenaming) && (types != null)) && (types.allEquivalenceClasses().size() > 1)
compiler.report(JSError.make(t.getSourceName(), n, DisambiguateProperties.INVALIDATION, name, type == null ? "null" : type.toString(), n.toString()))
compiler.report(JSError.make(t.getSourceName(), child, DisambiguateProperties.INVALIDATION, name, type == null ? "null" : type.toString(), n.toString()))
return (objType != null) && (!objType.hasReferenceName())
return type.isEnumType() || (type.autoboxesTo() != null)
return (((type == null) || type.isAll()) || type.isFunction()) || (type.isInstance() && invalidatingTypes.contains(type.toInstance().instanceType))
Preconditions.checkState(externsAndJs != null)
Preconditions.checkState((externsRoot == null) || externsAndJs.hasChild(externsRoot))
Preconditions.checkState(scopeCreator == null)
Preconditions.checkState(topScope == null)
Preconditions.checkState(jsRoot.getParent() != null)
boolean superClassHasProperty = (superClass != null) && superClass.getPrototype().hasProperty(propertyName)
boolean declaredOverride = (info != null) && info.isOverride()
return ((parent == null) || (parent.getType() != Token.SCRIPT)) || (!t.getInput().isExtern())
Preconditions.checkState((gramps != null) && (gramps.getType() == Token.VAR))
return (displayName != null) && (!displayName.isEmpty())
return ObjectType.cast(autobox == null ? restricted : autobox)
return (v != null) && (!v.isLocal())
return s.getParent() == null
return (info != null) && ((info.isConstructor() && (valueNodeType == Token.FUNCTION)) || (info.hasEnumParameterType() && (valueNodeType == Token.OBJECTLIT)))
return ((!inExterns) && (!isGetOrSetDefinition())) && (isClassOrEnum || (((parent == null) || parent.canCollapseUnannotatedChildNames()) && ((globalSets > 0) || (localSets > 0))))
return (parent == null) || parent.canCollapseUnannotatedChildNames()
return parent == null
Preconditions.checkState((body.getNext() == null) && (body.getType() == Token.BLOCK))
Preconditions.checkNotNull(var == null)
assignedToUnknownValue = (value != null) && (!NodeUtil.isLiteralValue(value, true))
return getNode(n) != null
return (((n != null) && ((n.getType() == Token.CALL) || (n.getType() == Token.NEW))) && n.hasChildren()) && (qualifiedNameBeginsWithStripType(n.getFirstChild()) || nameEndsWithFieldNameToStrip(n.getFirstChild()))
return ((propNode != null) && (propNode.getType() == Token.STRING)) && isStripName(propNode.getString())
return (((name != null) && NodeUtil.isName(name)) && var.getName().equals(name.getString())) && NodeUtil.isAssignmentOp(n)
return (((name != null) && NodeUtil.isName(name)) && var.getName().equals(name.getString())) && (!NodeUtil.isLhs(name, name.getParent()))
Preconditions.checkState(compiler != null)
return currentInfo.getDescription() != null
return ((((((currentInfo.isConstructor() || currentInfo.isInterface()) || (currentInfo.getParameterCount() > 0)) || currentInfo.hasReturnType()) || currentInfo.hasBaseType()) || (currentInfo.getLendsName() != null)) || currentInfo.hasThisType()) || hasAnySingletonTypeTags()
assert record != null
Preconditions.checkState(externsAndJs != null)
Preconditions.checkState((externsRoot == null) || externsAndJs.hasChild(externsRoot))
return (info != null) && info.containsDeclaration()
allowDupe = (info != null) && info.getSuppressions().contains("duplicate")
return ((info != null) && info.hasParameterType(paramName)) && info.getParameterType(paramName).isOptionalArg()
return ((info != null) && info.hasParameterType(paramName)) && info.getParameterType(paramName).isVarArgs()
return properties.get(propertyName) != null
return className != null
return (input != null) && (input.getType() == Token.RETURN)
boolean aIsNull = (slotA == null) || (slotA.getType() == null)
boolean aIsNull = (slotA == null) || (slotA.getType() == null)
boolean bIsNull = (slotB == null) || (slotB.getType() == null)
boolean bIsNull = (slotB == null) || (slotB.getType() == null)
boolean shouldBeConstant = ((info != null) && info.isConstant()) || NodeUtil.isConstantByConvention(compiler.getCodingConvention(), n, parent)
Preconditions.checkState(externsAndJs != null)
return (var != null) && var.isConst()
return (string == null) || string.isEmpty()
Preconditions.checkState(result != null)
return registerFunction != null
return registerCall != null
Preconditions.checkState(nameNode != null)
Preconditions.checkState(value != null)
Preconditions.checkState(value != null)
return NodeUtil.isFunctionDeclaration(initialization.getParent()) || (initialization.getNameNode().getFirstChild() != null)
return !((ancestors.size() == 1) && (ancestors.peek().getNext() == null))
this.valueHasSideEffects = (valueNode != null) && NodeUtil.mayHaveSideEffects(valueNode)
return lookAhead != null
CheckNotNull  in 3924ms
